"""
CS 562 - Query Processing Engine for EMF/MF Queries
This module generates Python code to execute Extended Multi-Feature queries
based on the Phi operator specification.

Author: Rangasai Kumbhashi Raghavendra
CWID: 20028768
"""

import subprocess
import sys
from phi_parser import parse_phi
from models import PhiOperator

def get_aggregate_type(agg_func_name: str) -> str:
    """
    Determine the Python type for an aggregate function result.
    
    Args:
        agg_func_name: Name of aggregate function (e.g., 'sum_1_quant')
        
    Returns:
        Python type as string
    """
    if agg_func_name.split('_')[0] in ['sum', 'count', 'max', 'min']:
        return "0"
    elif agg_func_name.split('_')[0] == 'avg':
        return "0.0"
    return "0"

def generate_mf_struct(phi: PhiOperator) -> str:
    """
    Generate the MFStruct class definition with all necessary fields.
    
    Args:
        phi: PhiOperator object containing query specification
        
    Returns:
        String containing the class definition
    """
    struct_code = "    class MFStruct:\n"
    struct_code += "        def __init__(self):\n"
    
    # Add grouping attributes
    for attr in phi.V:
        struct_code += f"            self.{attr} = ''\n"
    
    # Add aggregate function fields
    for func in phi.F:
        func_type = func.split('_')[0]  # sum, avg, count, etc. (first part)
        
        if func_type == 'sum':
            struct_code += f"            self.{func} = {get_aggregate_type(func)}\n"
        elif func_type == 'count':
            struct_code += f"            self.{func} = {get_aggregate_type(func)}\n"
        elif func_type == 'avg':
            struct_code += f"            self.{func}_sum = {get_aggregate_type('sum_' + func)}\n"
            struct_code += f"            self.{func}_count = {get_aggregate_type('count_' + func)}\n"
            struct_code += f"            self.{func} = {get_aggregate_type(func)}\n"
        elif func_type == 'max':
            struct_code += f"            self.{func} = float('-inf')\n"
        elif func_type == 'min':
            struct_code += f"            self.{func} = float('inf')\n"
    
    struct_code += "\n"
    return struct_code

def generate_output_code(phi: PhiOperator) -> str:
    """
    Generate code to output results using PrettyTable.
    
    Args:
        phi: PhiOperator object containing query specification
        
    Returns:
        String containing output code
    """
    output_code = "    # Generate output table\n"
    output_code += "    table = PrettyTable()\n"
    output_code += f"    table.field_names = {phi.S}\n\n"
    
    output_code += "    for obj in data:\n"
    output_code += "        row = []\n"
    output_code += "        for field in table.field_names:\n"
    output_code += "            row.append(getattr(obj, field))\n"
    output_code += "        table.add_row(row)\n\n"
    
    output_code += "    return table\n"
    
    return output_code

def generate_query_code(phi: PhiOperator) -> str:
    """
    Generate complete Python code for the query processing engine.
    
    Args:
        phi: PhiOperator object containing query specification
        
    Returns:
        Complete Python code as string
    """
    code = """import os
import psycopg2
import psycopg2.extras
from prettytable import PrettyTable
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    \"\"\"
    Execute the EMF query and return results as a PrettyTable.
    \"\"\"
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor, host='127.0.0.1', port='5432')
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
"""
    
    # Add MFStruct definition
    code += generate_mf_struct(phi)

    # Initialize data structure
    code += """    # For entries in the H-Table    
    data = []
"""
    code += """    # To ensure distinct records based on grouping-attributes   
    group_by_map = {}\n
"""
    
    # First scan: populate data with distinct grouping attribute values
    code += "    # First scan: Create entries for distinct grouping attribute values\n"
    code += "    for row in cur:\n"
    
    # Create key from grouping attributes
    key_parts = [f"row.get('{attr}')" for attr in phi.V]
    code += f"        key = ({', '.join(key_parts)})\n"
    code += "        \n"
    code += "        if key not in group_by_map:\n"
    code += "            entry = MFStruct()\n"
    
    # Set grouping attribute values
    for attr in phi.V:
        code += f"            entry.{attr} = row.get('{attr}')\n"
    
    code += "            data.append(entry)\n"
    code += "            group_by_map[key] = len(data) - 1\n\n"

    # Generate output
    code += generate_output_code(phi)
    
    # Main execution
    code += """
if __name__ == "__main__":
    print(query())
"""
    
    return code

def main():
    """
    Main function to generate and optionally execute the query processing engine.
    """
    if len(sys.argv) < 2:
        print("Usage: python generator.py <input_file> [--run]")
        print("  <input_file>: Path to Phi operator specification file")
        print("  --run: Optional flag to execute generated code immediately")
        sys.exit(1)
    
    input_file = sys.argv[1]
    should_run = len(sys.argv) > 2 and sys.argv[2] == "--run"
    
    # Parse Phi operator from input file
    print(f"Parsing Phi operator from {input_file}...")
    phi = parse_phi(input_file)
    
    if phi is None:
        print("Error: Failed to parse Phi operator")
        sys.exit(1)
    
    print("Successfully parsed Phi operator:")
    print(f"  Grouping attributes: {phi.V}")
    print(f"  Number of grouping variables: {phi.N}")
    print(f"  Aggregate functions: {phi.F}")
    print(f"  Select attributes: {phi.S}")
    
    # Generate query code
    print("\nGenerating query processing code...")
    code = generate_query_code(phi)
    
    # Write to file
    output_file = "_generated.py"
    with open(output_file, "w") as f:
        f.write(code)
    
    print(f"Generated code written to {output_file}")
    
    # Execute if requested
    if should_run:
        print("\nExecuting generated code...")
        subprocess.run([sys.executable, output_file])

if __name__ == "__main__":
    main()
